问题记录:
1. spring session attribute 多个 controller 共享对象失败,需要寻找原因
2. registry.addViewController("/login").setViewName("login"); 妈的这里配置为何不起作用

除了Equals和Between操作之外，Spring Data方法签名还能包括如下的操作符：•IsAfter、After、IsGreaterThan、GreaterThan•IsGreaterThanEqual、GreaterThanEqual•IsBefore、Before、IsLessThan、LessThan•IsLessThanEqual、LessThanEqual•IsBetween、Between•IsNull、Null•IsNotNull、NotNull•IsIn、In•IsNotIn、NotIn•IsStartingWith、StartingWith、StartsWith•IsEndingWith、EndingWith、EndsWith•IsContaining、Containing、Contains•IsLike、Like•IsNotLike、NotLike•IsTrue、True•IsFalse、False•Is、Equals•IsNot、Not•IgnoringCase、IgnoresCase

Spring Security为配置用户存储提供了多个可选方案，包括：•基于内存的用户存储；•基于JDBC的用户存储；•以LDAP作为后端的用户存储；•自定义用户详情服务。

Spring Security提供了内置的CSRF保护。更幸运的是，默认它就是启用的，我们不需要显式配置它。我们唯一需要做的就是确保应用中的每个表单都要有一个名为“_csrf”的字段，它会持有CSRF token。

尽管我们将server.port属性显式设置成了0，但是服务器并不会真的在端口0上启动。相反，它会任选一个可用的端口。在我们运行自动化集成测试的时候，这会非常有用，因为这样能够保证并发运行的测试不会与硬编码的端口号冲突,如果不关心应用在哪个端口启动，那么这种配置方式也非常有用，因为此时应用将会变成通过服务注册中心来进行查找的微服务

默认情况下，Spring Boot通过Logback配置日志，日志会以INFO级别写入到控制台中

当为Spring Data repository创建端点的时候，Spring Data REST会尝试使用相关实体类的复数形式。对于Ingredient实体来说，端点将会是“/ingredients”，对于Order和User实体，端点将会是“/orders”和“/users”

•REST端点可以通过Spring MVC来创建，这里的控制器与面向浏览器的控制器遵循相同的编程模型。
•为了绕过视图和模型的逻辑并将数据直接写入响应体中，控制器处理方法既可以添加@ResponseBody注解也可以返回ResponseEntity对象。
•@RestController注解简化了REST控制器，使用它的话，处理器方法中就不需要添加@ResponseBody注解了。
•Spring HATEOAS为Spring MVC控制器返回的资源启用了超链接功能。
•借助Spring Data REST，Spring Data repository可以自动导出为REST API。



•异步消息在要通信的应用程序之间提供了一个中间层，这样能够实现更松散的耦合和更强的可扩展性。
•Spring支持使用JMS、RabbitMQ或Apache Kafka实现异步消息。
•应用程序可以使用基于模板的客户端（JmsTemplate、RabbitTemplate或KafkaTemplate）向消息代理发送消息。
•接收消息的应用程序可以借助相同的基于模板的客户端以拉取模式消费消息。
•通过使用消息监听器注解（@JmsListener、@RabbitListener或@KafkaListener），消息也可以推送至消费者的bean方法中。\



•通道（channel）：将消息从一个元素传递到另一个元素。

•过滤器（filter）：基于某些断言，条件化地允许某些消息通过流。

•转换器（transformer）：改变消息的值和/或将消息载荷从一种类型转换成另一种类型。

•路由器（router）：将消息路由至一个或多个通道，通常会基于消息的头信息进行路由。

•切分器（splitter）：将传入的消息切割成两个或更多的消息，然后将每个消息发送至不同的通道；

•聚合器（aggregator）：切分器的反向操作，将来自不同通道的多个消息合并成一个消息。

•服务激活器（service activator）：将消息传递给某个Java方法来进行处理，并将返回值发布到输出通道上。

•通道适配器（channel adapter）：将通道连接到某些外部系统或传输方式，可以接受输入，也可以写出到外部系统。

•网关（gateway）：通过接口将数据传递到集成流中。

---

Spring Integration提供了多种通道实现。

•PublishSubscribeChannel：发送到PublishSubscribeChannel的消息会被传递到一个或多个消费者中。如果有多个消费者，它们都会接收到消息。

•QueueChannel：发送到QueueChannel的消息会存储到一个队列中，会按照先进先出（FirstIn First Out，FIFO）的方式被拉取出来。如果有多个消费者，只有其中的一个消费者会接收到消息。

•PriorityChannel：与QueueChannel类似，但它不是FIFO的方式，而是会基于消息的priority头信息被消费者拉取出来。

•RendezvousChannel：与QueueChannel类似，但是发送者会一直阻塞通道，直到消费者接收到消息为止，实际上会同步发送者和消费者。

•DirectChannel：与PublishSubscribeChannel类似，但是消息只会发送至一个消费者，它会在与发送者相同的线程中调用消费者。这种方式允许事务跨通道。

•ExecutorChannel：类似于DirectChannel，但是消息分发是通过TaskExecutor实现的，这样会在与发送者独立的线程中执行。这种通道类型不支持事务跨通道。

•FluxMessageChannel：反应式流的发布者消息通道，基于Reactor项目的Flux。（我们将会在第10章讨论反应式流、Reactor和Flux。）



















